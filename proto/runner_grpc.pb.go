// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: runner.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RunnerClient is the client API for Runner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RunnerClient interface {
	Init(ctx context.Context, in *InitRunnerRequest, opts ...grpc.CallOption) (*Null, error)
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*Null, error)
	Clear(ctx context.Context, in *Null, opts ...grpc.CallOption) (*Null, error)
	RobotName(ctx context.Context, in *Null, opts ...grpc.CallOption) (*RobotNameResponse, error)
	GetCapabilities(ctx context.Context, in *Null, opts ...grpc.CallOption) (*GetCapabilitiesResponse, error)
}

type runnerClient struct {
	cc grpc.ClientConnInterface
}

func NewRunnerClient(cc grpc.ClientConnInterface) RunnerClient {
	return &runnerClient{cc}
}

func (c *runnerClient) Init(ctx context.Context, in *InitRunnerRequest, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/proto.Runner/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/proto.Runner/Run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) Clear(ctx context.Context, in *Null, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/proto.Runner/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) RobotName(ctx context.Context, in *Null, opts ...grpc.CallOption) (*RobotNameResponse, error) {
	out := new(RobotNameResponse)
	err := c.cc.Invoke(ctx, "/proto.Runner/RobotName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerClient) GetCapabilities(ctx context.Context, in *Null, opts ...grpc.CallOption) (*GetCapabilitiesResponse, error) {
	out := new(GetCapabilitiesResponse)
	err := c.cc.Invoke(ctx, "/proto.Runner/GetCapabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerServer is the server API for Runner service.
// All implementations must embed UnimplementedRunnerServer
// for forward compatibility
type RunnerServer interface {
	Init(context.Context, *InitRunnerRequest) (*Null, error)
	Run(context.Context, *RunRequest) (*Null, error)
	Clear(context.Context, *Null) (*Null, error)
	RobotName(context.Context, *Null) (*RobotNameResponse, error)
	GetCapabilities(context.Context, *Null) (*GetCapabilitiesResponse, error)
	mustEmbedUnimplementedRunnerServer()
}

// UnimplementedRunnerServer must be embedded to have forward compatible implementations.
type UnimplementedRunnerServer struct {
}

func (UnimplementedRunnerServer) Init(context.Context, *InitRunnerRequest) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedRunnerServer) Run(context.Context, *RunRequest) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedRunnerServer) Clear(context.Context, *Null) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedRunnerServer) RobotName(context.Context, *Null) (*RobotNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RobotName not implemented")
}
func (UnimplementedRunnerServer) GetCapabilities(context.Context, *Null) (*GetCapabilitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCapabilities not implemented")
}
func (UnimplementedRunnerServer) mustEmbedUnimplementedRunnerServer() {}

// UnsafeRunnerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunnerServer will
// result in compilation errors.
type UnsafeRunnerServer interface {
	mustEmbedUnimplementedRunnerServer()
}

func RegisterRunnerServer(s grpc.ServiceRegistrar, srv RunnerServer) {
	s.RegisterService(&Runner_ServiceDesc, srv)
}

func _Runner_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Runner/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Init(ctx, req.(*InitRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Runner/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Run(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Runner/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).Clear(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_RobotName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).RobotName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Runner/RobotName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).RobotName(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runner_GetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Null)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerServer).GetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Runner/GetCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerServer).GetCapabilities(ctx, req.(*Null))
	}
	return interceptor(ctx, in, info, handler)
}

// Runner_ServiceDesc is the grpc.ServiceDesc for Runner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Runner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Runner",
	HandlerType: (*RunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Init",
			Handler:    _Runner_Init_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _Runner_Run_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _Runner_Clear_Handler,
		},
		{
			MethodName: "RobotName",
			Handler:    _Runner_RobotName_Handler,
		},
		{
			MethodName: "GetCapabilities",
			Handler:    _Runner_GetCapabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner.proto",
}

// RobotHelperClient is the client API for RobotHelper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RobotHelperClient interface {
}

type robotHelperClient struct {
	cc grpc.ClientConnInterface
}

func NewRobotHelperClient(cc grpc.ClientConnInterface) RobotHelperClient {
	return &robotHelperClient{cc}
}

// RobotHelperServer is the server API for RobotHelper service.
// All implementations must embed UnimplementedRobotHelperServer
// for forward compatibility
type RobotHelperServer interface {
	mustEmbedUnimplementedRobotHelperServer()
}

// UnimplementedRobotHelperServer must be embedded to have forward compatible implementations.
type UnimplementedRobotHelperServer struct {
}

func (UnimplementedRobotHelperServer) mustEmbedUnimplementedRobotHelperServer() {}

// UnsafeRobotHelperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RobotHelperServer will
// result in compilation errors.
type UnsafeRobotHelperServer interface {
	mustEmbedUnimplementedRobotHelperServer()
}

func RegisterRobotHelperServer(s grpc.ServiceRegistrar, srv RobotHelperServer) {
	s.RegisterService(&RobotHelper_ServiceDesc, srv)
}

// RobotHelper_ServiceDesc is the grpc.ServiceDesc for RobotHelper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RobotHelper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RobotHelper",
	HandlerType: (*RobotHelperServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "runner.proto",
}

// DebugClient is the client API for Debug service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DebugClient interface {
	Attach(ctx context.Context, in *AttachRequest, opts ...grpc.CallOption) (*Nil, error)
	Detach(ctx context.Context, in *DetachRequest, opts ...grpc.CallOption) (*Nil, error)
}

type debugClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugClient(cc grpc.ClientConnInterface) DebugClient {
	return &debugClient{cc}
}

func (c *debugClient) Attach(ctx context.Context, in *AttachRequest, opts ...grpc.CallOption) (*Nil, error) {
	out := new(Nil)
	err := c.cc.Invoke(ctx, "/proto.Debug/Attach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugClient) Detach(ctx context.Context, in *DetachRequest, opts ...grpc.CallOption) (*Nil, error) {
	out := new(Nil)
	err := c.cc.Invoke(ctx, "/proto.Debug/Detach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugServer is the server API for Debug service.
// All implementations must embed UnimplementedDebugServer
// for forward compatibility
type DebugServer interface {
	Attach(context.Context, *AttachRequest) (*Nil, error)
	Detach(context.Context, *DetachRequest) (*Nil, error)
	mustEmbedUnimplementedDebugServer()
}

// UnimplementedDebugServer must be embedded to have forward compatible implementations.
type UnimplementedDebugServer struct {
}

func (UnimplementedDebugServer) Attach(context.Context, *AttachRequest) (*Nil, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attach not implemented")
}
func (UnimplementedDebugServer) Detach(context.Context, *DetachRequest) (*Nil, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detach not implemented")
}
func (UnimplementedDebugServer) mustEmbedUnimplementedDebugServer() {}

// UnsafeDebugServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugServer will
// result in compilation errors.
type UnsafeDebugServer interface {
	mustEmbedUnimplementedDebugServer()
}

func RegisterDebugServer(s grpc.ServiceRegistrar, srv DebugServer) {
	s.RegisterService(&Debug_ServiceDesc, srv)
}

func _Debug_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Debug/Attach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).Attach(ctx, req.(*AttachRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Debug_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Debug/Detach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServer).Detach(ctx, req.(*DetachRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Debug_ServiceDesc is the grpc.ServiceDesc for Debug service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Debug_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Debug",
	HandlerType: (*DebugServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Attach",
			Handler:    _Debug_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _Debug_Detach_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner.proto",
}
